{"componentChunkName":"component---src-templates-post-tsx","path":"/setting-up-processing-gatsby-react/","result":{"data":{"mdx":{"frontmatter":{"title":"Setting Up Processing + Gatsby + React","date":"11 April, 2020"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Setting Up Processing + Gatsby + React\",\n  \"date\": \"2020-04-11\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the things I wanted to do with this site is use the awesome Processing\\nfor JavaScript library \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" is a pretty sweet library, but it\\u2019s not\\ndesigned to be used with React \\u2013 at least, not easily.\"), mdx(\"p\", null, \"For this project, we'll be trying to get the following MDX file working properly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"---\\ntitle: \\\"Basic Sketch\\\"\\ndate: \\\"2020-04-11\\\"\\n---\\n\\nimport \\\"p5\\\"\\n\\n<Sketch\\n    setup={(p, canvasParentRef) => {\\n        p.createCanvas(640,480).parent(canvasParentRef)\\n        p.noLoop()\\n    }}\\n\\n    draw={(p) => {\\n        p.cirlce(p.width/2, p.height/2, 80)\\n    }}\\n/>\\n\")), mdx(\"h1\", null, \"Problem 1: Getting \", mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"p5.js\"), \" Into React\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" is meant to be delivered via CDN to a website, not used as an NPM\\npackage. This doesn\\u2019t mean you can\\u2019t, there \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is\"), \" an official p5.js NPM\\npackage. However, using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" this way is not as simple or elegant as using\\nit the usual way. The biggest difference is that you must create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5\"), \" object\\nthat contains all your sketch\\u2019s functions and link that object to a canvas\\nelement.\"), mdx(\"p\", null, \"While trivial to accomplish in React, I found a handy React component that\\nalready put in the leg work: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-p5\"), mdx(\"sup\", _extends({\n    parentName: \"p\"\n  }, {\n    \"id\": \"fnref-1\"\n  }), mdx(\"a\", _extends({\n    parentName: \"sup\"\n  }, {\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }), \"1\")), \". This package provides a Sketch\\ncomponent that allowed me to provide \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setup()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"draw()\"), \", and all the other\\nusual \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" sketch functions as props. The Sketch component then handles all\\nthe management of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \".\"), mdx(\"h1\", null, \"Problem 2: Not Breaking the Gatsby Build\"), mdx(\"p\", null, \"Sweet! We\\u2019ve got \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" into our Gatsby React websit- Fuck, the build\\u2019s broken.\"), mdx(\"p\", null, \"Ain\\u2019t that the way. Well, what exactly is the problem? Gatsby complains about\\nthere being no variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window\"), \" defined:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \" ERROR \\n\\nThere was an error compiling the html.js component for the development server.\\n\\nSee our docs page on debugging HTML builds for help https://gatsby.dev/debug-html ReferenceError: window is not defined\\n\\n\\n  69915 |           // requestAnimationFrame polyfill by Erik M\\xF6ller\\n  69916 |           // fixes from Paul Irish and Tino Zijdel        \\n> 69917 |           window.requestAnimationFrame = (function() {    \\n        | ^\\n  69918 |             return (\\n  69919 |               window.requestAnimationFrame ||\\n  69920 |               window.webkitRequestAnimationFrame ||\\n\\n\\n  WebpackError: ReferenceError: window is not defined\\n\")), mdx(\"p\", null, \"For those just learning Gatsby, like myself at the time of writing this,\\nthat\\u2019s a little confusing. Why should Gatsby care that window isn\\u2019t defined?\\nIsn\\u2019t it just rendering our components as HTML?\"), mdx(\"p\", null, \"Yes, yes, it is rendering our components to HTML. And the problem is found\\nthere: Gatsby uses native React functions to render HTML components outside\\nof the browser environment, much like how test renderers work. When Gatsby\\ndoes this, it makes a very big assumption: your components don\\u2019t use browser\\ndefined variables.\"), mdx(\"p\", null, \"Now this assumption isn\\u2019t without reason. If your pages are supposed to be\\nstatically rendered, they shouldn\\u2019t use browser defined variables when being\\nrendered. It defeats the whole purpose of being statically rendered if they\\ndepend on the client.\"), mdx(\"p\", null, \"But, obviously, we sometimes want to use browser variables. This means we\\nhave to trick Gatsby into not rendering our components that violate its core\\nassumption.\"), mdx(\"h1\", null, \"Enter: The Loadable Component\"), mdx(\"p\", null, \"Turns out that this is such a common problem in the React ecosystem that\\nthere\\u2019s a library out there for it. It\\u2019s called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@loadable/component\"), \", and it\\nprovides a decorator for creating loadable components.\"), mdx(\"p\", null, \"On the tin, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@loadable/component\"), \" states that it provides \\u201CReact code splitting\\nmade easy.\\u201D Being new to React, that makes zero sense. But after some\\nresearch, I found that code splitting is the practice of literally splitting\\nyour code into separate bundles. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@loadable/component\"), \" does this by providing a\\ndecorator that accepts a function that returns the result of a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dynamic import\"), \"\\nas its parameter.\"), mdx(\"p\", null, \"This decorator generates a wrapper component that renders the component that\\nthe dynamic import returns. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This all assumes that the component you want to\\nrender is the \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"default export\"), \" of the module you are loading. If it\\u2019s not,\\nthis whole thing breaks\"), \". Luckily for us, React standard practice dictates\\nthat the component you want people to render is always the default export,\\nand the author of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-p5\"), \" follows that standard practice.\"), mdx(\"p\", null, \"This allows for some, almost deceptively, simple code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"import loadable from \\\"@loadable/component\\\"\\n\\nconst Sketch = loadable(() => import(\\\"react-p5\\\"))\\n\")), mdx(\"p\", null, \"The component created can be passed into MDXProvider component as a shortcode\\nthat can be used by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-plugin-mdx\"), \" plugin:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"const shortcodes = { Sketch }\\n\\nconst Template = () => (\\n    <MDXProvider shortcodes={shortcodes}>\\n        ...\\n    </MDXProvider>\\n)\\n\")), mdx(\"p\", null, \"Why this saves our bacon is because Gatsby, under the hood, uses Webpack to\\nbundle the client-side code. Webpack automatically registers that when it\\nsees a dynamic import, the code that is imported needs to be isolated into\\nits own bundle that will be loaded by the client during runtime. And because\\ndynamic imports can only happen during runtime, Gatsby\\u2019s React renderer\\nignores them when performing static rendering, preventing it from trying to\\nexecute code that needs to be run in the browser.\"), mdx(\"h1\", null, \"\\\"Your Solution is Trash, My Build is Still Broke\\\"\"), mdx(\"p\", null, \"If you checked your Gatsby build, you probably noticed that it\\u2019s still broke.\\nAnd you\\u2019ll also have noticed that Gatsby is still complaining about the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window\"), \" variable not being defined. So, sounds like code splitting didn\\u2019t\\nsave us at all.\"), mdx(\"p\", null, \"But this is a different error. Our loadable component can\\u2019t save us from\\nneeding to include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p5.js\"), \" in our sketch file, which can\\u2019t be lazily loaded\\nsince our sketch file's code get's executed outside of our area of influence.\\nFor this we need a different trick: null loading client-only modules.\"), mdx(\"p\", null, \"This is a trick that comes from Webpack. To implement it, we have to edit (or\\nin some cases, create) a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file that contains the following\\nsnippet:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"exports.onCreateWebpackConfig = ({ stage, loaders, actions }) => {\\n    if (stage === \\\"build-html\\\" || stage === \\\"develop-html\\\") {\\n        actions.setWebpackConfig({\\n            module: {\\n                rules: [\\n                    {\\n                        test: /p5/,\\n                        use: loaders.null()\\n                    }\\n                ]\\n            }\\n        })\\n    }\\n}\\n\")), mdx(\"p\", null, \"What this snippet does is modify the generated Webpack configuration made by\\nGatsby\\u2019s build routine with a module rule that states: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"If a package contains\\nthe string \\u201Cp5\\u201D, load it with the null-loader\"), \". This null-loader passes a null\\nmodule to Webpack, preventing it from trying to bundle the module and causing\\na build error.\"), mdx(\"p\", null, \"If you restart the Gatsby development server and watch the initial build, it\\nwill succeed without so much as a peep! (Assuming the rest of your build\\nisn\\u2019t causing grief!)\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ol\"\n  }, {\n    \"id\": \"fn-1\"\n  }), \"There is an alternative package you can use called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"react-p5-wrapper\"), \",\\nwhich accomplishes the same task, but accepts different props. I chose\\n\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"react-p5\"), \" because I could inline my p5.js functions into the component\\ninstead of having to encapsulate them in a function.\", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }), \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"One of the things I wanted to do with this site is use the awesome Processing\nfor JavaScript library  p5.js .  p5.js  is a pretty sweet…"},"site":{"siteMetadata":{"title":"JRM.DEV","author":{"name":"Joseph R Miles"}}}},"pageContext":{"slug":"/setting-up-processing-gatsby-react/"}},"staticQueryHashes":["1985666601"]}