{"componentChunkName":"component---src-templates-post-tsx","path":"/software-testing-second-age/","result":{"data":{"mdx":{"frontmatter":{"title":"Front-End Testing in the Dusk of the Second Age","date":"28 May, 2020"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Front-End Testing in the Dusk of the Second Age\",\n  \"date\": \"2020-05-28T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Shawn Wang has pointed out that the world of JavaScript and Front End\\nsoftware development may be on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.swyx.io/writing/js-third-age/\"\n  }), \"the cusp of Third\\nAge\"), \", and I for one could not\\nbe happier to jump on that band-wagon. But, alas, I\\u2019ve saddled myself with\\nseveral projects written in the technology that has defined this Second Age:\\nReact. In my exploration of React and it\\u2019s ecosystem (and embarking on a few\\nprojects that are perhaps too ambitious to do alone), I have found only one\\nthing truly befuddling about building modern JavaScript applications:\\ntesting.\"), mdx(\"p\", null, \"Near the beginning of this last month, I published an article about \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/building-testing-intuition/\"\n  }), \"how I\\nwas going to spend the month writing shitty\\ntests\"), \". And I\\u2019m happy to report that I have, in\\nfact, written many, many shitty tests. Have I written enough that I can now\\nwrite amazing tests? No, no I haven\\u2019t, and it may take me years before I\\nfinally get to that point (perhaps this coming Third Age has an answer to my\\nstrife).\"), mdx(\"p\", null, \"I have, however, learned. In particular, the most informative experience I\\nhave had this month was reading the excellent \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software Testing\"), \",\\nthe bible for the field of software testing that has still managed to endure\\n(with a handful of revisions) for nearly 40 years. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software\\nTesting\"), \" brought back semi-forgotten memories of sitting through my software\\nengineering class in college and clarified many things I had always wondered\\nabout \", \"\\u2014\", \" the biggest being perhaps how a good test is formulated. What follows\\nis a series of lessons I\\u2019ve learned over the last month, both from this book,\\nand from the escapades I\\u2019ve had thus far trying to write tests for the\\nfront-end.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Disclaimer: What follows are the opinionated ramblings of a some-what\\neducated software developer who is taking their first steps into this wild\\nworld of front-end web development.\")), mdx(\"h1\", null, \"Testing Intuition Isn\\u2019t Total Gibberish\"), mdx(\"p\", null, \"I want to get this out of the way, since \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/building-testing-intuition/\"\n  }), \"the topic of the last article I\\nwrote on software testing\"), \" was the idea of\\n\\u201Ctesting intuition\\u201D. Looking back at that article, and perhaps to no one\\u2019s\\nsurprise, it\\u2019s very clear I had no idea what I was talking about. Which aptly\\ndescribes the level of knowledge I had about testing at the time (and\\nprobably still maintain).\"), mdx(\"p\", null, \"Turns out, however, that the notion of \\u201Ctesting intuition\\u201D is not complete\\ngibberish. In the chapters discussing how one goes about formulating tests,\\nthe authors of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software Testing\"), \" do address something similar,\\nwhich they refer to as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"error guessing\"), \". Error guessing is described as the\\nprocess where:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Given a particular program, \", \"[the tester will]\", \" surmise, \", \"\\u2014\", \" both by\\nintuition and experience \", \"\\u2014\", \" certain probable types of errors and then\\nwrite test cases to expose those errors.\")), mdx(\"p\", null, \"This practice is reasonably ill-advised, since it\\u2019s not backed by any kind of\\nrigid system or methodology like other kinds of test case creation. But, it\\ndoes help get to the most obvious (or maybe least obvious) test cases,\\nallowing you to spend more effort on discovering the less trivial test cases\\nthat are needed for a piece of software.\"), mdx(\"h1\", null, \"Software Testing Is For Humans Too\"), mdx(\"p\", null, \"What originally started my dive into testing on the front-end was an\\napplication I was working on for \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/JoeBobMiles/TableTop\"\n  }), \"collaboratively playing\\nD&D\"), \" and other table-top\\nrole-playing games online. This kind of application, which is very heavy in\\nthe graphics department, is plain \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"hard\"), \" to test.\"), mdx(\"p\", null, \"Take, for example, the Token component, which represents a character on the\\ngame board. This component has a few simple requirements:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Show a portrait of the character\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Move with the user\\u2019s mouse cursor when the user clicks and drags the Token.\")), mdx(\"p\", null, \"As informal as these requirements are, they are accurate to the basic\\nfunctions of the component. And both of these are impossible to test via an\\nautomated process. Why?\"), mdx(\"p\", null, \"Take, for example, the first requirement: \\u201CShow a portrait of the character\\u201D.\\nThis is a pretty bad requirement, since \\u2018show\\u2019 could mean a few things. A\\nbetter requirement, and one that is centered around what the user will care\\nabout, is: \\u201COn the token, a user shall see a portrait of the character that\\ntoken represents\\u201D. And this is where the trouble begins: how do you verify\\nthat your user can see the portrait with an automatic test runner? Sure,\\nthere are shortcuts, like checking that the Token has an image element\\nembedded in it, and that the image element is pointing to the right image\\nfile. But how do you know if the image element is visible? You need several\\nboundary tests to check that every possible configuration of the Token keeps\\nthe image element visible.\"), mdx(\"p\", null, \"But what if you added an offset to the image, or applied a shape mask over\\nthe image to make it render in a way that was appealing? How do you verify\\nthat the offset doesn\\u2019t send the image off the screen? How do you verify that\\nthe shape mask doesn\\u2019t fully obscure the image? These are things that are\\nincredibly hard to test in an automated setup, usually requiring visual\\nregression testing that checks the visual appearance of a component. But most\\ninfluential people in the modern testing scene consider these tests fragile,\\nsince visual regression testing requires pixel-by-pixel comparisons to a\\nprior snapshot of the token\\u2019s appearance.\"), mdx(\"p\", null, \"Ergo, you will inevitably need a user to verify that the simple requirement\\n\\u201CShow a portrait of the character\\u201D is satisfied. And this shouldn\\u2019t be\\nsurprising, since human testing is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the first\"), \" testing method that is talked\\nabout in The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Art of Software Testing\"), \". And I\\u2019d argue, it\\u2019s more valuable than\\nintegration tests in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kentcdodds.com/blog/unit-vs-integration-vs-e2e-tests\"\n  }), \"\\u201Ctrophy\\u201D of software\\ntesting\"), \",\\nsimply because a human saying \\u201Csomething looks funny\\u201D can provide a lot more\\ninformation than a machine saying \\u201Csomething looks funny\\u201D.\"), mdx(\"h1\", null, \"Confidence In The Details\"), mdx(\"p\", null, \"The thing that bugs me the most about the mantra \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kentcdodds.com/blog/testing-implementation-details\"\n  }), \"\\u201Cdon\\u2019t test implementation\\ndetails\\u201D\"), \" that\\nseems to dominate the discussion of front-end software testing is that the\\nmethodology idolizes the concept of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"black-box testing\"), \". For the unfamiliar,\\nblack-box testing is the idea of testing a program by feeding data in and\\nthen checking that the data that comes out is correct. While not inherently\\nproblematic, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software Testing\"), \" illustrates that this is a\\nterrible way to go about testing software, since it would require an\\nuntenable number of black-box tests to fully confirm that the software\\ncontains no or, at the least, very few bugs. (Not to mention there may be\\nsome requirements that cannot be verified by checking outputs alone.)\"), mdx(\"p\", null, \"There is another way to perform testing \", \"\\u2014\", \" the reverse of black-box\\ntesting \", \"\\u2014\", \" known as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"white-box testing\"), \". This kind of testing validates\\nthat the software meets requirements by using knowledge of the software\\u2019s\\ninner workings. In other words, white-box testing tests those vile\\nimplementation details. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software Testing\"), \" talks about these kinds\\nof tests as well, but gives them the same verdict as black-box testing: you\\ncannot reasonably use only white-box tests to validate that your software is\\nfree of bugs.\"), mdx(\"p\", null, \"The solution, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The Art of Software Testing\"), \" proposes, is a combination of\\nstrategically designed black-box and white-box tests. By verifying that your\\ncode yields outputs that satisfy the requirements, and internally functions\\nwithin the specifications, you can have an incredible amount of confidence in\\nthe code you deliver with a reasonable, but by no means \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"small\"), \", number of\\ntests. And it\\u2019s this methodology I stand by, for reasons I have observed over\\nthe last month of writing shitty tests.\"), mdx(\"p\", null, \"The primary reason I standby the \\u201Cgrey-box\\u201D testing method is because for\\nevery code base there are two categories of users: end-users and developers.\\nBlack-box testing is perfect for satisfying end-users, and some classes of\\ndevelopers (those, for instance, who consume some data processing API), but\\ndoesn\\u2019t work so well when the developers have to interact with your code\\nstructure (i.e. a fellow teammate) and be confident that when they change\\nsomething, the code doesn\\u2019t suddenly break\"), mdx(\"aside\", null, \"The lack of completeness to this argument irks me, but I do feel that it's the right one to make.\"), mdx(\"h1\", null, \"Specifications are Gold\"), mdx(\"p\", null, \"From my journey in testing so far, the biggest pain I have suffered is\\nsitting down to write the tests for a component and not knowing what to start\\nwith. Trying to hold to the principle of TDD, in these situations I had no\\nactual component to test, only tests to write to describe the component I\\nwould build. But I almost always ended up staring at a blinking cursor,\\nsuffering a case of analysis paralysis as my brain went into a small\\nexistential crisis about what the hell I was actually trying to build.\"), mdx(\"p\", null, \"And I\\u2019m sure that it\\u2019s no surprise to anyone that it\\u2019s hard to write tests\\nwithout knowing what the specification for the component is. Shooting from\\nthe hip is a great way to watch a project fall apart because none of the\\ntests are testing things that really matter. Or worse, there\\u2019s no tests at\\nall. Unfortunately, writing specifications can send one down the rabbit hole\\nof requirements engineering and software architecture. A rabbit hole I\\u2019m all\\ntoo familiar with at this point and has led a few too many projects to rot.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"There\\u2019s a lot I have yet to figure out about this testing business with\\nmodern, front-end web applications, but I think that this past month has been\\na decent start towards learning a little bit more about the subject. My next\\ngoal is to start playing with other tools for building front-ends, like Vue\\nand the shiny new framework Svelte (which I and so many other devs seem to\\nadore), and learning if testing with them are any different from testing with\\nReact, or if it is fraught with all the same problems.\"), mdx(\"p\", null, \"But for now, my key takeaways are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ABT: Always Be Testing. The more tests you write, the quicker and easier\\nit will be to recognize potential problem areas and write tests to cover\\nthem.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Don\\u2019t forget the humans. Automated tests are great, but there are some\\nthings computers still can\\u2019t help us test. In those cases, don\\u2019t be afraid\\nto invite a person to help you!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The devil\\u2019s in the details. Leaving implementation details untested is\\nasking for poor developer experience and software architecture.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Stop! And write yourself some specifications! Don\\u2019t build software you\\nintend to test without first knowing what it\\u2019s expected to do (and not do).\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Shawn Wang has pointed out that the world of JavaScript and Front End\nsoftware development may be on  the cusp of Third\nAge , and I for one…"},"site":{"siteMetadata":{"title":"JRM.DEV","author":{"name":"Joseph R Miles"}}}},"pageContext":{"slug":"/software-testing-second-age/"}},"staticQueryHashes":["1985666601"]}